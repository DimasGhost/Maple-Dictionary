Основы
	with (LinearAlgebra) // Подключить модуль линейной алгебры
	a := 5 // Присвоение переменных
	a := 'a' // Стирание переменных
	restart // Сброс программы
	(Ctrl + Shift + _) // Писать индекс
	rand() // Случайное число
	% // Последний вывод

Матрицы
	Matrix([[1, 2], [3, 4]]) // Создание матрицы
	< <1 | 2>, <3 | 4> > // Аналогично
	ZeroMatrix(3, 3) // Нулевая матрица
	RandomMatrix(3, 3) // Случайная матрица
	RandomMatrix(3, 3, density = .75, generator = 0 ..1.5) // ?
	DiagonalMatrix([1, 2, 3]) // Нулевая матрица с заданными элементами на диагонали
	Dimension(A) // Размерность матрицы
	ColumnDimension(A) // Кол-во стобцов
	RowDimension(A) // Кол-во строк
	Determinant(A) // Определитель матрицы
	A.B // Умножение матриц
	A*~B // Поэлементное умножение
	SubMatrix(A, 1..3, 2..4) // Подматрица
	SubMatrix(A, [1, 3], [2, 4]) // Подматрица
	RowOperation(A, [1, 2]) // Поменять местами 1 и 2 строку
	RowOperation(A, 4, 2) // Умножить вторую строку на 2
	RowOperation(A, [2, 3], 2) // Прибавить ко второй строке третью умноженную на 2
	ColumnOperation // аналог RowOperation
	Row(B, 1) // Первая строка матрицы
	Row(B, 1 .. 2) // 1..2 строки матрицы
	Column // Аналог Row
	GaussianElimination(A) // Ступенчатый вид
	MatrixInverse(A) // Обратная матрица
	IdentityMatrix(3) // Единичная матрица
	<M, E> // Склейка матриц построчно
	ReducedRowEchelonForm(A) // Канонический вид
	Minor(M, 2, 2) // Минор, если вычеркнуть 2 строку и 2 столбец
	Transpose(M) // Транспонировать матрицу
	Matrix([seq([seq(Minor(M, i, j) * (-1) ^ (i + j), i = 1 ..3)], j = 1 ..3)]) // Союзная матрица
	LinearSolve(A, B) // Решает AX = B

Графики
	plot(A) // График по матрице А
	plot([sinh(x), cosh(x)], x = -2..2) // График по заданным функциям
	plot([x*x], x=-5..5, color=[blue], axes=boxed) // Рамка графика
	with(plots) // Подключение графиков
	listplot(A) // График по массиву A
	listplot(A, connect = false) // Не соединять точки
	listplot([A, B, C]) // Построение нескольких графиков по массивам

Геометрия
	with(geometry) // Подключение геометрии
	point(P, x, y) // Задание точки P
	circle(C, point(O, 0, 0), 1) // Задание окружности C с радиусом 1 в точке O(0, 0)
	draw([A, B, C], color = [red, blue, blue]) // Нарисовать элементы A, B, C с соотв. цветами
	line(L, [P1, P2]) // Задание линии L через точки P1 и P2
	Equation(L) // Уравнение прямой L
	FindAngle(L1, L2) // Угол между прямыми
	AreParallel(L1, L2) // Параллельны ли
	ArePerpendicular(L1, L2) // Перпендикулярны ли
	ParallelLine(LP, L, A) // Генерирует прямую LP параллельную L и проходящую через точку A
	PerpendicularLine(LP, L, A) // Генерирует прямую LP перпендикулярную L и проходящую через точку A
	distance(L, A) // Расстояние от прямой L до точки A
	line(L, x + y = 0) // Прямая по уравнению
	triangle(T, [A, B, C]) // Треугольник по трем точкам
	coordinates(P) // Координаты
	detail(T) // Детали
	area(T) // Площадь
	perimeter(T) // Периметр
	intersection(Q, L, C) // Q = точка пересечения

Трехмерная геометрия
	with(geom3d) // Подключение трехмерной геометрии
	sphere(S, a^2 + b^2 + c^2 = 4) // Сфера по уравнению
	plane(P, 2x + 3y + 4z + 5 = 0) // Плоскость по уравнению
	plane(P, [A, n]) // Плоскость по точке и нормали
	plane(P, [L1, L2]) // Плоскость через две прямые
	plane(P, [A, B, C]) // Плоскость через три точки
	plot3d() // Аналог plot

Выражения
	evalf(pi) // Считает действительное значение (индекс - кол-во знаков)
	solve(x ^ 5 = 10) // Решает уравнение
	s := solve({x + y + z = 1, x - y = 2, x - z + y = 3}) // Решает уравнение
	subs(s, [x, y, z]) // Подстановка
	subs(x = 2, x^2 + x * t) // Пример подстановки
	simplify() // Упрощает выражение
	factor() // Раскладывает на множители
	expand() // Раскрывает скобки
	[seq(x * x, x = 1 .. 3)] // Генерирует массив квадратов от 1 до 3
	f := n -> n * n // Лямбда функция (f(n) = n * n)
	isolve(x > 5) // Решает уравнение в целых числах
	isolve({1 / i > 1 / (i + 1), i > 0}) // Решение системы в целых числах
	limit(1/x, x=0, real) // Находит предел выражения
	limit(1/x, x=infinity, real) // x может быть равен числу, infinity, -infinity
	limit(1/x, x=5, left) // Направление может быть	left, right, real, complex
	g := x->piecewise(x > 0, x, x <= 0, -x) // кусочная функция
	discont(f(x), x) // находит разрывы
	numer(x) // числитель дроби x
	denom(x) // знаменатель дроби x
	diff(f(x), x) // находит производную функции f(x) по x
	f'(x) // производная
	coeff(2x + 3y + 4, x) // Находит коэффицент при x
	coeff(2x + 3y + 4, y, 0) // Показывает выражение без y
	int(x^2, x) // Находит интеграл по x
	int(x^2, x=a..b) // Находит интеграл по x на отрезке [a, b]
	extrema(x^2, {}, x) // Находит экстремумы выражения
	minimize(cos(x), x=1..5) // Находит минимум функции на отрезке 1..5
	minimize(cos(x), x=1..5, location) // Показывает точки
	maximize // см. minimize

Комплексные числа
	z := 1 + 2 I // Комплексное число
	Complex(1, 2) // Комплексное число
	abs(z) // Модуль комплексного числа
	argument(z) // Угол комплексного числа
	conjugate(z) // Сопряженное число
	Re(z) // Действительная часть
	Im(z) // Мнимая часть
	polar(z) // Полярное представление
	evalc(z) // Вычисления с комплексными числами

Функции и операторы
	// Пример функции
	f := proc(a, b)
		local i;
		if a = b then
			print('equal');
		else;
			print('unequal');
		end if;
		for i from a to b do
			print(i);
		od;
		return a;
	end
